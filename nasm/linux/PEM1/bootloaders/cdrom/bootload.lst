     1                                  ; ==================================================================
     2                                  ; The Mike Operating System bootloader
     3                                  ; Copyright (C) 2006 - 2013 MikeOS Developers -- see doc/LICENSE.TXT
     4                                  ;
     5                                  ; Based on a free boot loader by E Dehling. It scans the FAT12
     6                                  ; floppy for KERNEL.BIN (the MikeOS kernel), loads it and executes it.
     7                                  ; This must grow no larger than 512 bytes (one sector), with the final
     8                                  ; two bytes being the boot signature (AA55h). Note that in FAT12,
     9                                  ; a cluster is the same as a sector: 512 bytes.
    10                                  ; ==================================================================
    11                                  
    12                                  	BITS 16
    13                                  
    14 00000000 EB3C                    	jmp short bootloader_start	; Jump past disk description section
    15 00000002 90                      	nop				; Pad out before disk description
    16                                  
    17                                  
    18                                  ; ------------------------------------------------------------------
    19                                  ; Disk description table, to make it a valid floppy
    20                                  ; Note: some of these values are hard-coded in the source!
    21                                  ; Values are those used by IBM for 1.44 MB, 3.5" diskette
    22                                  
    23 00000003 50454D31424F4F54        OEMLabel		db "PEM1BOOT"	; Disk label
    24 0000000B 0002                    BytesPerSector		dw 512		; Bytes per sector
    25 0000000D 01                      SectorsPerCluster	db 1		; Sectors per cluster
    26 0000000E 0100                    ReservedForBoot		dw 1		; Reserved sectors for boot record
    27 00000010 02                      NumberOfFats		db 2		; Number of copies of the FAT
    28 00000011 E000                    RootDirEntries		dw 224		; Number of entries in root dir
    29                                                                          ; (224 * 32 = 7168 = 14 sectors to read)
    30 00000013 400B                    LogicalSectors		dw 2880		; Number of logical sectors
    31 00000015 F0                      MediumByte		db 0F0h		; Medium descriptor byte
    32 00000016 0900                    SectorsPerFat		dw 9		; Sectors per FAT
    33 00000018 1200                    SectorsPerTrack		dw 18		; Sectors per track (36/cylinder)
    34 0000001A 0200                    Sides			dw 2		; Number of sides/heads
    35 0000001C 00000000                HiddenSectors		dd 0		; Number of hidden sectors
    36 00000020 00000000                LargeSectors		dd 0		; Number of LBA sectors
    37 00000024 0000                    DriveNo			dw 0		; Drive No: 0
    38 00000026 29                      Signature		db 41		; Drive signature: 41 for floppy
    39 00000027 00000000                VolumeID		dd 00000000h	; Volume ID: any number
    40 0000002B 41474755524F2D5045-     VolumeLabel		db "AGGURO-PEM1"; Volume Label: any 11 chars
    41 00000034 4D31               
    42 00000036 4641543132202020        FileSystem		db "FAT12   "	; File system type: don't change!
    43                                  
    44                                  
    45                                  ; ------------------------------------------------------------------
    46                                  ; Main bootloader code
    47                                  ; boot:
    48                                    ;     Boot code here - set segment registers etc...
    49                                    
    50                                  bootloader_start:
    51 0000003E B8C007                  	mov ax, 07C0h			; Set up 4K of stack space above buffer
    52 00000041 052002                  	add ax, 544			; 8k buffer = 512 paragraphs + 32 paragraphs (loader)
    53 00000044 FA                      	cli				; Disable interrupts while changing stack
    54 00000045 8ED0                    	mov ss, ax
    55 00000047 BC0010                  	mov sp, 4096
    56 0000004A FB                      	sti				; Restore interrupts
    57                                  
    58 0000004B B8C007                  	mov ax, 07C0h			; Set data segment to where we're loaded
    59 0000004E 8ED8                    	mov ds, ax
    60                                  
    61                                  	; NOTE: A few early BIOSes are reported to improperly set DL
    62                                  
    63 00000050 80FA00                  	cmp dl, 0
    64 00000053 741D                    	je no_change
    65 00000055 8816[F201]              	mov [bootdev], dl		; Save boot device number
    66 00000059 B408                    	mov ah, 8			; Get drive parameters
    67 0000005B CD13                    	int 13h
    68 0000005D 0F828D00                	jc fatal_disk_error
    69 00000061 83E13F                  	and cx, 3Fh			; Maximum sector number
    70 00000064 890E[1800]              	mov [SectorsPerTrack], cx	; Sector numbers start at 1
    71 00000068 0FB6D6                  	movzx dx, dh			; Maximum head number
    72 0000006B 83C201                  	add dx, 1			; Head numbers start at 0 - add 1 for total
    73 0000006E 8916[1A00]              	mov [Sides], dx
    74                                  
    75                                  no_change:
    76 00000072 66B800000000            	mov eax, 0			; Needed for some older BIOSes
    77                                  
    78                                  
    79                                  ; First, we need to load the root directory from the disk. Technical details:
    80                                  ; Start of root = ReservedForBoot + NumberOfFats * SectorsPerFat = logical 19
    81                                  ; Number of root = RootDirEntries * 32 bytes/entry / 512 bytes/sector = 14
    82                                  ; Start of user data = (start of root) + (number of root) = logical 33
    83                                  
    84                                  floppy_ok:				; Ready to read first block of data
    85 00000078 B81300                  	mov ax, 19			; Root dir starts at logical sector 19
    86 0000007B E80901                  	call l2hts
    87                                  
    88 0000007E BE[0002]                	mov si, buffer			; Set ES:BX to point to our buffer (see end of code)
    89 00000081 8CDB                    	mov bx, ds
    90 00000083 8EC3                    	mov es, bx
    91 00000085 89F3                    	mov bx, si
    92                                  
    93 00000087 B402                    	mov ah, 2			; Params for int 13h: read floppy sectors
    94 00000089 B00E                    	mov al, 14			; And read 14 of them
    95                                  
    96 0000008B 60                      	pusha				; Prepare to enter loop
    97                                  
    98                                  
    99                                  read_root_dir:
   100 0000008C 61                      	popa				; In case registers are altered by int 13h
   101 0000008D 60                      	pusha
   102                                  
   103 0000008E F9                      	stc				; A few BIOSes do not set properly on error
   104 0000008F CD13                    	int 13h				; Read sectors using BIOS
   105                                  
   106 00000091 7308                    	jnc search_dir			; If read went OK, skip ahead
   107 00000093 E8E200                  	call reset_floppy		; Otherwise, reset floppy controller and try again
   108 00000096 73F4                    	jnc read_root_dir		; Floppy reset OK?
   109                                  
   110 00000098 E9C500                  	jmp reboot			; If not, fatal double error
   111                                  
   112                                  
   113                                  search_dir:
   114 0000009B 61                      	popa
   115                                  
   116 0000009C 8CD8                    	mov ax, ds			; Root dir is now in [buffer]
   117 0000009E 8EC0                    	mov es, ax			; Set DI to this info
   118 000000A0 BF[0002]                	mov di, buffer
   119                                  
   120 000000A3 8B0E[1100]              	mov cx, word [RootDirEntries]	; Search all (224) entries
   121 000000A7 B80000                  	mov ax, 0			; Searching at offset 0
   122                                  
   123                                  
   124                                  next_root_entry:
   125 000000AA 87CA                    	xchg cx, dx			; We use CX in the inner loop...
   126                                  
   127 000000AC BE[B201]                	mov si, kern_filename		; Start searching for kernel filename
   128 000000AF B90B00                  	mov cx, 11
   129 000000B2 F3A6                    	rep cmpsb
   130 000000B4 7415                    	je found_file_to_load		; Pointer DI will be at offset 11
   131                                  
   132 000000B6 83C020                  	add ax, 32			; Bump searched entries by 1 (32 bytes per entry)
   133                                  
   134 000000B9 BF[0002]                	mov di, buffer			; Point to next entry
   135 000000BC 01C7                    	add di, ax
   136                                  
   137 000000BE 87D1                    	xchg dx, cx			; Get the original CX back
   138 000000C0 E2E8                    	loop next_root_entry
   139                                  
   140 000000C2 BE[DC01]                	mov si, file_not_found		; If kernel is not found, bail out
   141 000000C5 E8A200                  	call print_string
   142 000000C8 E99500                  	jmp reboot
   143                                  
   144                                  
   145                                  found_file_to_load:			; Fetch cluster and load FAT into RAM
   146 000000CB 268B450F                	mov ax, word [es:di+0Fh]	; Offset 11 + 15 = 26, contains 1st cluster
   147 000000CF A3[F301]                	mov word [cluster], ax
   148                                  
   149 000000D2 B80100                  	mov ax, 1			; Sector 1 = first sector of first FAT
   150 000000D5 E8AF00                  	call l2hts
   151                                  
   152 000000D8 BF[0002]                	mov di, buffer			; ES:BX points to our buffer
   153 000000DB 89FB                    	mov bx, di
   154                                  
   155 000000DD B402                    	mov ah, 2			; int 13h params: read (FAT) sectors
   156 000000DF B009                    	mov al, 9			; All 9 sectors of 1st FAT
   157                                  
   158 000000E1 60                      	pusha				; Prepare to enter loop
   159                                  
   160                                  
   161                                  read_fat:
   162 000000E2 61                      	popa				; In case registers are altered by int 13h
   163 000000E3 60                      	pusha
   164                                  
   165 000000E4 F9                      	stc
   166 000000E5 CD13                    	int 13h				; Read sectors using the BIOS
   167                                  
   168 000000E7 730D                    	jnc read_fat_ok			; If read went OK, skip ahead
   169 000000E9 E88C00                  	call reset_floppy		; Otherwise, reset floppy controller and try again
   170 000000EC 73F4                    	jnc read_fat			; Floppy reset OK?
   171                                  
   172                                  ; ******************************************************************
   173                                  fatal_disk_error:
   174                                  ; ******************************************************************
   175 000000EE BE[BD01]                	mov si, disk_error		; If not, print error message and reboot
   176 000000F1 E87600                  	call print_string
   177 000000F4 EB6A                    	jmp reboot			; Fatal double error
   178                                  
   179                                  
   180                                  read_fat_ok:
   181 000000F6 61                      	popa
   182                                  
   183 000000F7 B80020                  	mov ax, 2000h			; Segment where we'll load the kernel
   184 000000FA 8EC0                    	mov es, ax
   185 000000FC BB0000                  	mov bx, 0
   186                                  
   187 000000FF B402                    	mov ah, 2			; int 13h floppy read params
   188 00000101 B001                    	mov al, 1
   189                                  
   190 00000103 50                      	push ax				; Save in case we (or int calls) lose it
   191                                  
   192                                  
   193                                  ; Now we must load the FAT from the disk. Here's how we find out where it starts:
   194                                  ; FAT cluster 0 = media descriptor = 0F0h
   195                                  ; FAT cluster 1 = filler cluster = 0FFh
   196                                  ; Cluster start = ((cluster number) - 2) * SectorsPerCluster + (start of user)
   197                                  ;               = (cluster number) + 31
   198                                  
   199                                  load_file_sector:
   200 00000104 A1[F301]                	mov ax, word [cluster]		; Convert sector to logical
   201 00000107 83C01F                  	add ax, 31
   202                                  
   203 0000010A E87A00                  	call l2hts			; Make appropriate params for int 13h
   204                                  
   205 0000010D B80020                  	mov ax, 2000h			; Set buffer past what we've already read
   206 00000110 8EC0                    	mov es, ax
   207 00000112 8B1E[F501]              	mov bx, word [pointer]
   208                                  
   209 00000116 58                      	pop ax				; Save in case we (or int calls) lose it
   210 00000117 50                      	push ax
   211                                  
   212 00000118 F9                      	stc
   213 00000119 CD13                    	int 13h
   214                                  
   215 0000011B 7305                    	jnc calculate_next_cluster	; If there's no error...
   216                                  
   217 0000011D E85800                  	call reset_floppy		; Otherwise, reset floppy and retry
   218 00000120 EBE2                    	jmp load_file_sector
   219                                  
   220                                  
   221                                  	; In the FAT, cluster values are stored in 12 bits, so we have to
   222                                  	; do a bit of maths to work out whether we're dealing with a byte
   223                                  	; and 4 bits of the next byte -- or the last 4 bits of one byte
   224                                  	; and then the subsequent byte!
   225                                  
   226                                  calculate_next_cluster:
   227 00000122 A1[F301]                	mov ax, [cluster]
   228 00000125 BA0000                  	mov dx, 0
   229 00000128 BB0300                  	mov bx, 3
   230 0000012B F7E3                    	mul bx
   231 0000012D BB0200                  	mov bx, 2
   232 00000130 F7F3                    	div bx				; DX = [cluster] mod 2
   233 00000132 BE[0002]                	mov si, buffer
   234 00000135 01C6                    	add si, ax			; AX = word in FAT for the 12 bit entry
   235 00000137 3E8B04                  	mov ax, word [ds:si]
   236                                  
   237 0000013A 09D2                    	or dx, dx			; If DX = 0 [cluster] is even; if DX = 1 then it's odd
   238                                  
   239 0000013C 7405                    	jz even				; If [cluster] is even, drop last 4 bits of word
   240                                  					; with next cluster; if odd, drop first 4 bits
   241                                  
   242                                  odd:
   243 0000013E C1E804                  	shr ax, 4			; Shift out first 4 bits (they belong to another entry)
   244 00000141 EB03                    	jmp short next_cluster_cont
   245                                  
   246                                  
   247                                  even:
   248 00000143 25FF0F                  	and ax, 0FFFh			; Mask out final 4 bits
   249                                  
   250                                  
   251                                  next_cluster_cont:
   252 00000146 A3[F301]                	mov word [cluster], ax		; Store cluster
   253                                  
   254 00000149 3DF80F                  	cmp ax, 0FF8h			; FF8h = end of file marker in FAT12
   255 0000014C 7308                    	jae end
   256                                  
   257 0000014E 8106[F501]0002          	add word [pointer], 512		; Increase buffer pointer 1 sector length
   258 00000154 EBAE                    	jmp load_file_sector
   259                                  
   260                                  
   261                                  end:					; We've got the file to load!
   262 00000156 58                      	pop ax				; Clean up the stack (AX was pushed earlier)
   263 00000157 8A16[F201]              	mov dl, byte [bootdev]		; Provide kernel with boot device info
   264                                  
   265 0000015B EA00000020              	jmp 2000h:0000h			; Jump to entry point of loaded kernel!
   266                                  
   267                                  
   268                                  ; ------------------------------------------------------------------
   269                                  ; BOOTLOADER SUBROUTINES
   270                                  
   271                                  reboot:
   272 00000160 B80000                  	mov ax, 0
   273 00000163 CD16                    	int 16h				; Wait for keystroke
   274 00000165 B80000                  	mov ax, 0
   275 00000168 CD19                    	int 19h				; Reboot the system
   276                                  
   277                                  
   278                                  print_string:				; Output string in SI to screen
   279 0000016A 60                      	pusha
   280                                  
   281 0000016B B40E                    	mov ah, 0Eh			; int 10h teletype function
   282                                  
   283                                  .repeat:
   284 0000016D AC                      	lodsb				; Get char from string
   285 0000016E 3C00                    	cmp al, 0
   286 00000170 7404                    	je .done			; If char is zero, end of string
   287 00000172 CD10                    	int 10h				; Otherwise, print it
   288 00000174 EBF7                    	jmp short .repeat
   289                                  
   290                                  .done:
   291 00000176 61                      	popa
   292 00000177 C3                      	ret
   293                                  
   294                                  
   295                                  reset_floppy:		; IN: [bootdev] = boot device; OUT: carry set on error
   296 00000178 50                      	push ax
   297 00000179 52                      	push dx
   298 0000017A B80000                  	mov ax, 0
   299 0000017D 8A16[F201]              	mov dl, byte [bootdev]
   300 00000181 F9                      	stc
   301 00000182 CD13                    	int 13h
   302 00000184 5A                      	pop dx
   303 00000185 58                      	pop ax
   304 00000186 C3                      	ret
   305                                  
   306                                  
   307                                  l2hts:			; Calculate head, track and sector settings for int 13h
   308                                  			; IN: logical sector in AX, OUT: correct registers for int 13h
   309 00000187 53                      	push bx
   310 00000188 50                      	push ax
   311                                  
   312 00000189 89C3                    	mov bx, ax			; Save logical sector
   313                                  
   314 0000018B BA0000                  	mov dx, 0			; First the sector
   315 0000018E F736[1800]              	div word [SectorsPerTrack]
   316 00000192 80C201                  	add dl, 01h			; Physical sectors start at 1
   317 00000195 88D1                    	mov cl, dl			; Sectors belong in CL for int 13h
   318 00000197 89D8                    	mov ax, bx
   319                                  
   320 00000199 BA0000                  	mov dx, 0			; Now calculate the head
   321 0000019C F736[1800]              	div word [SectorsPerTrack]
   322 000001A0 BA0000                  	mov dx, 0
   323 000001A3 F736[1A00]              	div word [Sides]
   324 000001A7 88D6                    	mov dh, dl			; Head/side
   325 000001A9 88C5                    	mov ch, al			; Track
   326                                  
   327 000001AB 58                      	pop ax
   328 000001AC 5B                      	pop bx
   329                                  
   330 000001AD 8A16[F201]              	mov dl, byte [bootdev]		; Set correct device
   331                                  
   332 000001B1 C3                      	ret
   333                                  
   334                                  
   335                                  ; ------------------------------------------------------------------
   336                                  ; STRINGS AND VARIABLES
   337                                  
   338 000001B2 4B45524E454C202042-     	kern_filename	db "KERNEL  BIN"	; MikeOS kernel filename
   339 000001BB 494E               
   340                                  
   341 000001BD 466C6F707079206572-     	disk_error	db "Floppy error! Press any key...", 0
   342 000001C6 726F72212050726573-
   343 000001CF 7320616E79206B6579-
   344 000001D8 2E2E2E00           
   345 000001DC 4B45524E454C2E4249-     	file_not_found	db "KERNEL.BIN not found!", 0
   346 000001E5 4E206E6F7420666F75-
   347 000001EE 6E642100           
   348                                  
   349 000001F2 00                      	bootdev		db 0 	; Boot device number
   350 000001F3 0000                    	cluster		dw 0 	; Cluster of the file we want to load
   351 000001F5 0000                    	pointer		dw 0 	; Pointer into Buffer, for loading kernel
   352                                  
   353                                  
   354                                  ; ------------------------------------------------------------------
   355                                  ; END OF BOOT SECTOR AND BUFFER START
   356                                  
   357 000001F7 00<rept>                	times 510-($-$$) db 0	; Pad remainder of boot sector with zeros
   358 000001FE 55AA                    	dw 0AA55h		; Boot signature (DO NOT CHANGE!)
   359                                  
   360                                  
   361                                  buffer:				; Disk buffer begins (8k after this, stack starts)
   362                                  
   363                                  
   364                                  ; ==================================================================
